// PiSSTVpp

// 2013 Robert Marshall KI4MCW
// 2014 Gerrit Polder, PA3BYA fixed header. 
// 2014 Don Gi Min, KM4EQR, more protocols and option handling
// 2024 Stephen Garriga, added image format detection and expanded protocol support
// 2026 Andrew Blessing, rewrite and enhancements

/* ============================================================================
 * PiSSTVpp
 *
 * Recommended Raspberry Pi builds (choose ONE):
 *
 *   Generic Pi / portable (safe everywhere):
 *     gcc -O3 -ffast-math -funroll-loops \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 *   Build ON the target Pi (best performance for that exact CPU):
 *     gcc -O3 -ffast-math -funroll-loops -march=native \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 *   Pi 1 / Zero / Zero W  (ARMv6, VFP):
 *     gcc -O3 -ffast-math -funroll-loops \
 *         -march=armv6 -mfpu=vfp -mfloat-abi=hard \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 *   Pi 2 (ARMv7, NEON+VFPv4):
 *     gcc -O3 -ffast-math -funroll-loops \
 *         -march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 *   Pi 3 (ARMv8-A 32-bit userland, Cortex-A53):
 *     gcc -O3 -ffast-math -funroll-loops \
 *         -march=armv8-a -mtune=cortex-a53 -mfpu=neon-fp-armv8 -mfloat-abi=hard \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 *   Pi 4 / 400 (Cortex-A72):
 *     gcc -O3 -ffast-math -funroll-loops \
 *         -march=armv8-a -mtune=cortex-a72 -mfpu=neon-fp-armv8 -mfloat-abi=hard \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 *   Pi 5 (Cortex-A76, ARMv8.2-A):
 *     gcc -O3 -ffast-math -funroll-loops \
 *         -march=armv8.2-a -mtune=cortex-a76 \
 *         -o PiSSTVpp PiSSTVpp.c -lgd -lmagic -lm
 *
 * Notes:
 *   - Put libraries AFTER the source/object files (linker order matters).
 *   - Add -lm because you use sin()/M_PI from libm.
 *   - If you are cross-compiling or distributing binaries, do NOT use
 *     -march=native; pick the appropriate -march/-mtune instead.
 * ============================================================================ */


// ===========
// includes
// ===========

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include <gd.h>
#include <time.h>
#include <math.h>
#include <tgmath.h>
#include <magic.h>
#include <unistd.h>

// ================
// macros/defines
// ================

#define RATE        22050          // default audio sample rate in Hz 
#define MAXRATE     48000          // max audio sample rate in Hz
#define BITS        16             // bits per audio sample
#define CHANS       1              // audio channels
#define VOLPCT      20             // volume percent (of max 90% to avoid clipping)
#define MAXSAMPLES (300 * MAXRATE) // max samples for 5 minutes at MAXRATE

#define MAGIC_PNG ("PNG image data,") 
#define MAGIC_JPG ("JPEG image data")
#define MAGIC_GIF ("GIF image data")
/* libmagic commonly reports BMP as "PC bitmap, ..." (not always "BMP image data") */
#define MAGIC_BMP ("PC bitmap")

/* Longest prefix above is "PNG image data," (15 chars) and "GIF image data" (14),
   but "PC bitmap" is shorter. Keep 15 for compatibility. */
#define MAGIC_CNT 15

#define FILETYPE_ERR 0
#define FILETYPE_PNG 1
#define FILETYPE_JPG 2
#define FILETYPE_GIF 3
#define FILETYPE_BMP 4

#define APP_NAME "PiSSTVpp"
#define APP_VERSION "2.1.0"
#define APP_BUILD_DATE __DATE__

// =========
// globals
// =========

int16_t   g_audio[MAXSAMPLES] ;
uint32_t   g_scale, g_samples ;
double     g_twopioverrate , g_uspersample ; 
double     g_theta, g_fudge ; 
uint8_t    g_protocol; //VIS ID's for SSTV protocols

FILE *     g_imgfp ;
FILE *     g_outfp ;
gdImagePtr g_imgp ;
uint16_t   g_rate;


typedef enum {
    OUTFMT_WAV = 0,
    OUTFMT_AIFF = 1
} outfmt_t;

static outfmt_t g_outfmt = OUTFMT_WAV;

/* Case-insensitive string endswith */
static int endswith_ci(const char *s, const char *suffix)
{
    if (!s || !suffix) return 0;
    size_t sl = strlen(s), su = strlen(suffix);
    if (su > sl) return 0;
    s += (sl - su);
    for (size_t i = 0; i < su; i++) {
        char a = s[i], b = suffix[i];
        if (a >= 'A' && a <= 'Z') a = (char)(a - 'A' + 'a');
        if (b >= 'A' && b <= 'Z') b = (char)(b - 'A' + 'a');
        if (a != b) return 0;
    }
    return 1;
}

/* Infer output format from filename extension. Defaults to WAV. */
static outfmt_t infer_outfmt_from_name(const char *path)
{
    if (!path) return OUTFMT_WAV;
    if (endswith_ci(path, ".aif") || endswith_ci(path, ".aiff"))
        return OUTFMT_AIFF;
    if (endswith_ci(path, ".wav"))
        return OUTFMT_WAV;
    return OUTFMT_WAV;
}


// ========
// protos
// ========

uint8_t  filetype       (char *filename) ;
void     playtone       (uint16_t tonefreq , double tonedur) ;
void     addvisheader   (void) ;
void     addvistrailer  (void) ;

uint16_t toneval_rgb        (uint8_t colorval) ;
uint16_t toneval_yuv        (uint8_t colorval) ;

void     buildaudio_m       (double pixeltime) ;
void     buildaudio_s       (double pixeltime, uint16_t lines);
void     buildaudio_r36     (void) ;
void     buildaudio_r72     (void) ;
void     buildaudio_r36bw   (void) ;
void     buildaudio_r72bw   (void) ;

void     writefile_wav(void);
void     writefile_aiff(void);


/* ============================================================================
 * print_usage()
 *
 * Purpose:
 *   - Print command-line usage/help text for the SSTV image-to-audio encoder.
 *
 * Notes:
 *   - Updated to reflect expanded image input support (PNG/JPEG/GIF/BMP).
 *   - Updated to reflect expanded Scottie protocol support (S1/S2/S3/S4/DX/DX2).
 *   - VIS codes shown are the values used by this program’s protocol selector.
 *
 * IMPORTANT:
 *   - Ensure the VIS codes listed here match the values assigned in main()
 *     (g_protocol assignments). If you change mappings, update this help text.
 * ============================================================================ */
void print_usage(const char *progname)
{
    printf("Usage: %s -i <input_file> [OPTIONS]\n\n", progname);
    printf("%s v%s (built %s)\n", APP_NAME, APP_VERSION, APP_BUILD_DATE);
    printf("Convert an image (PNG/JPEG/GIF/BMP) to SSTV audio format.\n\n");

    printf("REQUIRED OPTIONS:\n");
    printf("  -i <file>       Input image file (PNG, JPEG, GIF, or BMP)\n\n");

    printf("OPTIONAL OPTIONS:\n");
    printf("  -o <file>       Output audio file (default: input_file.wav)\n");
    printf("  -p <protocol>   SSTV protocol to use (default: m1)\n");
    printf("                  Available protocols:\n");

    printf("                    m1     - Martin 1 (VIS 44)\n");
    printf("                    m2     - Martin 2 (VIS 40)\n");

    printf("                    s1     - Scottie 1 (VIS 60)\n");
    printf("                    s2     - Scottie 2 (VIS 56)\n");
    printf("                    s3     - Scottie 3 (VIS 52)\n");
    printf("                    s4     - Scottie 4 (VIS 48)\n");
    printf("                    sdx    - Scottie DX (VIS 76)\n");
    printf("                    sdx2   - Scottie DX2 (VIS 80)\n");

    printf("                    r36    - Robot 36 Color (VIS 8)\n");
    printf("                    r72    - Robot 72 Color (VIS 12)\n");

    /* NOTE: Your pasted Robot B&W VIS table suggests these may need revisiting.
       Keep these lines synchronized with main()’s g_protocol assignments. */
    printf("                    r36bw  - Robot 36 B&W (VIS 4)\n");
    printf("                    r72bw  - Robot 72 B&W (VIS 13)\n");

    printf("  -f <fmt>        Output format: wav or aiff (default: inferred from -o; default wav)\n");

    printf("  -r <rate>       Audio sample rate in Hz (default: %d)\n", RATE);
    printf("  -h              Display this help message\n\n");

    printf("EXAMPLES:\n");
    printf("  %s -i image.jpg -o out.aiff\n", progname);
    printf("  %s -i image.gif -o out.bin -f wav -p s2 -r 11025\n", progname);
    printf("  %s -i image.bmp -o output.wav -p r72\n\n", progname);
}


// ================
//   main
// ================

int main(int argc, char *argv[])
{
    char *protocol = "m1";  /* default protocol */
    char *inputfile = NULL;
    char *outputfile = NULL;
    int option;
    int fmt_forced = 0;

    g_rate = RATE;
    while ((option = getopt(argc, argv, "i:o:p:r:f:h")) != -1) {
        switch (option) {
            case 'i':
                inputfile = optarg;
                break;
            case 'o':
                outputfile = optarg;
                break;
            case 'r':
                g_rate = (atoi(optarg));
                break;
            case 'p':
                protocol = optarg;
                break;
            case 'f':
                fmt_forced = 1;
                if (strcmp(optarg, "wav") == 0) {
                    g_outfmt = OUTFMT_WAV;
                } else if (strcmp(optarg, "aiff") == 0 || strcmp(optarg, "aif") == 0) {
                    g_outfmt = OUTFMT_AIFF;
                } else {
                    fprintf(stderr, "Error: unknown format '%s' (use wav or aiff)\n", optarg);
                    return 1;
                }
                break;
            case 'h':
                print_usage(argv[0]);
                return 0;
            default:
                fprintf(stderr, "Unknown option: -%c\n", option);
                print_usage(argv[0]);
                return 1;
        }
    }

    /* Check if input file was provided */
    if (inputfile == NULL) {
        fprintf(stderr, "Error: Input file (-i) is required.\n\n");
        print_usage(argv[0]);
        return 1;
    }

    /* Set VIS codes (protocol selector) */
    if (strcmp(protocol, "m1") == 0) {
        g_protocol = 44; /* Martin 1 */
    }
    else if (strcmp(protocol, "m2") == 0) {
        g_protocol = 40; /* Martin 2 */
    }
    else if (strcmp(protocol, "s1") == 0) {
        g_protocol = 60; /* Scottie 1 */
    }
    else if (strcmp(protocol, "s2") == 0) {
        g_protocol = 56; /* Scottie 2 */
    }
    else if (strcmp(protocol, "s3") == 0) {
        g_protocol = 52; /* Scottie 3 */
    }
    else if (strcmp(protocol, "s4") == 0) {
        g_protocol = 48; /* Scottie 4 */
    }
    else if (strcmp(protocol, "sdx") == 0) {
        g_protocol = 76; /* Scottie DX */
    }
    else if (strcmp(protocol, "sdx2") == 0) {
        g_protocol = 80; /* Scottie DX2 */
    }
    else if (strcmp(protocol, "r36") == 0) {
        g_protocol = 8;  /* Robot 36 Color */
    }
    else if (strcmp(protocol, "r72") == 0) {
        g_protocol = 12; /* Robot 72 Color */
    }
    else if (strcmp(protocol, "r36bw") == 0) {
        g_protocol = 4;  /* Robot 36 B&W */
    }
    else if (strcmp(protocol, "r72bw") == 0) {
        g_protocol = 13; /* Robot 72 B&W */
    }
    else {
        fprintf(stderr, "Error: Unrecognized protocol option '%s'.\n", protocol);
        fprintf(stderr, "See -h for available protocols.\n\n");
        g_protocol = 44; /* default to Martin 1 */
    }

    /* locals */
    time_t starttime = time(NULL);
    uint8_t ft;
    char inputfile_buf[255], outputfile_buf[255];

    /* string hygiene */
    memset(inputfile_buf,  0, 255);
    memset(outputfile_buf, 0, 255);

    /* assign values to globals */
    double temp1, temp2, temp3;
    temp1 = (double)(1 << (BITS - 1));
    temp2 = VOLPCT / 100.0;
    temp3 = temp1 * temp2;
    g_scale = (uint32_t)temp3;

    g_twopioverrate = 2.0 * M_PI / g_rate;
    g_uspersample = 1000000.0 / (double)g_rate;

    g_theta = 0.0;
    g_samples = 0;
    g_fudge = 0.0;

    printf("Configuration:\n");
    printf("  Application: %s v%s\n", APP_NAME, APP_VERSION);
    printf("  Sample Rate: %d Hz\n", g_rate);
    printf("  VIS Code: %d\n", g_protocol);
    printf("  Bit Depth: %d bits\n", BITS);
    printf("  Volume: %d%%\n", VOLPCT);
    printf("  Scale Factor: %d\n", g_scale);
    printf("  µs/Sample: %.6f\n", g_uspersample);
    printf("  Angular Frequency: %.6f\n\n", g_twopioverrate);

    /* set filenames */
    snprintf(inputfile_buf, sizeof(inputfile_buf), "%s", inputfile);
    ft = filetype(inputfile_buf);
    if (ft == FILETYPE_ERR) {
        fprintf(stderr, "Error: Unable to determine file type. Ensure the input file is a supported image format (PNG, JPEG, GIF, BMP).\n");
        return 2;
    }

    /* Use provided output file or generate from input file */
    if (outputfile != NULL) {
        strncpy(outputfile_buf, outputfile, sizeof(outputfile_buf) - 1);
        outputfile_buf[sizeof(outputfile_buf) - 1] = '\0';

        /* If user did NOT supply -f, infer from output filename */
        if (!fmt_forced) {
            g_outfmt = infer_outfmt_from_name(outputfile_buf);
        }
    } else {
        strncpy(outputfile_buf, inputfile_buf, sizeof(outputfile_buf) - 1);
        outputfile_buf[sizeof(outputfile_buf) - 1] = '\0';

        /* Default format if nothing specified: WAV */
        if (g_outfmt != OUTFMT_AIFF && g_outfmt != OUTFMT_WAV)
            g_outfmt = OUTFMT_WAV;

        /* Append extension based on chosen/ default format */
        if (g_outfmt == OUTFMT_AIFF) strcat(outputfile_buf, ".aiff");
        else                         strcat(outputfile_buf, ".wav");
    }

    printf("Input Image:  %s\n", inputfile_buf);
    printf("Output Audio: %s\n", outputfile_buf);

    /* prep */
    g_imgfp = fopen(inputfile_buf, "rb");
    if (!g_imgfp) { perror("fopen input"); return 2; }

    g_outfp = fopen(outputfile_buf, "wb");
    if (!g_outfp) { perror("fopen output"); fclose(g_imgfp); return 2; }

    printf("[1/6] Files opened successfully.\n");

    if (ft == FILETYPE_JPG) {
        g_imgp = gdImageCreateFromJpeg(g_imgfp);
    }
    else if (ft == FILETYPE_PNG) {
        g_imgp = gdImageCreateFromPng(g_imgfp);
    }
    else if (ft == FILETYPE_GIF) {
        g_imgp = gdImageCreateFromGif(g_imgfp);
    }
    else if (ft == FILETYPE_BMP) {
        g_imgp = gdImageCreateFromBmp(g_imgfp);
    }
    else {
        fprintf(stderr, "Error: Unexpected file type encountered during image loading.\n");
        return 3;
    }

    printf("[2/6] Image loaded successfully.\n");

    /* go! */
    addvisheader();

    /* Select audio format mode */
    switch (g_protocol) {
        case 44: /* Martin 1 */
            buildaudio_m(457.6);
            break;
        case 40: /* Martin 2 */
            buildaudio_m(228.8);
            break;

        case 60: /* Scottie 1: 256 lines, 140.115 LPM */
            buildaudio_s(432.07, 256);
            break;
        case 56: /* Scottie 2: 256 lines, 216.067 LPM */
            buildaudio_s(275.20, 256);
            break;
        case 52: /* Scottie 3: 128 lines, 140.115 LPM */
            buildaudio_s(432.07, 128);
            break;
        case 48: /* Scottie 4: 128 lines, 216.067 LPM */
            buildaudio_s(275.20, 128);
            break;
        case 76: /* Scottie DX: 256 lines, 57.127 LPM */
            buildaudio_s(1079.92, 256);
            break;
        case 80: /* Scottie DX2: 256 lines, 112.905 LPM */
            buildaudio_s(539.56, 256);
            break;

        case 8:  /* Robot 36 Color */
            buildaudio_r36();
            break;
        case 12: /* Robot 72 Color */
            buildaudio_r72();
            break;
        case 4:  /* Robot 36 B&W */
            buildaudio_r36bw();
            break;
        case 13: /* Robot 72 B&W */
            buildaudio_r72bw();
            break;

        default:
            fprintf(stderr, "Error: Internal error - unknown protocol code %d during audio generation.\n", g_protocol);
            exit(2);
            break;
    }

    addvistrailer();

    if (g_outfmt == OUTFMT_AIFF) {
        writefile_aiff();
    } else {
        writefile_wav();
    }

    /* cleanup */
    fclose(g_imgfp);
    fclose(g_outfp);

    /* Report successful completion */
    printf("\n[6/6] Complete! SSTV audio file successfully created: %s\n", outputfile_buf);

    return 0;
}

// =====================
//  subs 
// =====================    


// filetype -- Check to see if input file is in one of our supported formats.
//             Uses libmagic to identify the file by content.
//
// Supported (after this update):
//   - JPEG (.jpg/.jpeg)  -> FILETYPE_JPG
//   - PNG  (.png)        -> FILETYPE_PNG
//   - GIF  (.gif)        -> FILETYPE_GIF
//   - BMP  (.bmp)        -> FILETYPE_BMP
//
// Notes:
//   - libmagic returns strings like "JPEG image data", "PNG image data",
//     "GIF image data", "PC bitmap, Windows 3.x format, ...", etc.
//   - We match by prefix to tolerate additional descriptive text.
//
uint8_t filetype(char *filename)
{
    magic_t m;
    char m_str[MAGIC_CNT + 2];
    uint8_t retval = FILETYPE_ERR;

    printf("  Detecting file type: %s\n", filename);

    m = magic_open(MAGIC_NONE);
    if (m && (magic_load(m, NULL) == 0)) {

        const char *desc = magic_file(m, filename);
        if (!desc) {
            fprintf(stderr, "  Error: Could not identify image type. File may be corrupted or unsupported.\n");
            retval = FILETYPE_ERR;
        } else {
            /* Copy a bounded prefix for strncmp-based matching */
            memset(m_str, 0, sizeof(m_str));
            strncpy(m_str, desc, MAGIC_CNT + 1);

            if (strncmp(m_str, MAGIC_JPG, MAGIC_CNT) == 0) {
                printf("  File is a JPEG image.\n");
                retval = FILETYPE_JPG;
            }
            else if (strncmp(m_str, MAGIC_PNG, MAGIC_CNT) == 0) {
                printf("  File is a PNG image.\n");
                retval = FILETYPE_PNG;
            }
            else if (strncmp(m_str, MAGIC_GIF, MAGIC_CNT) == 0) {
                printf("  File is a GIF image.\n");
                retval = FILETYPE_GIF;
            }
            /* BMP descriptions from libmagic often start with "PC bitmap" */
            else if (strncmp(m_str, MAGIC_BMP, MAGIC_CNT) == 0) {
                printf("  File is a BMP image.\n");
                retval = FILETYPE_BMP;
            }
            else {
                printf("  This file format is not supported!\n");
                printf("  Please use a JPEG, PNG, GIF, or BMP file instead.\n");
            }
        }
    } else {
        printf("  libmagic init/load failed.\n");
        retval = FILETYPE_ERR;
    }

    if (m) {
        magic_close(m);
    }

    return retval;
}


/* ============================================================================
 * playtone()
 *
 * Add waveform samples to the global audio buffer (g_audio[]) using a
 * phase-continuous sine generator.
 *
 * Inputs:
 *   - tonefreq : frequency in Hz (0 = silence)
 *   - tonedur  : duration in microseconds (may be fractional)
 *
 * Timing model:
 *   - Converts tonedur to an integer number of samples using g_uspersample
 *     (microseconds/sample) with rounding-to-nearest.
 *   - Carries fractional remainder forward in g_fudge so repeated calls
 *     achieve accurate *average* timing (error diffusion).
 *
 * Output-format neutrality:
 *   - This function no longer depends on compile-time AUDIO_WAV/AUDIO_AIFF
 *     macros and does not embed container-specific sample conventions.
 *   - The internal buffer is generated as canonical **signed 16-bit PCM**
 *     centered at 0 (silence = 0).
 *   - WAV vs AIFF differences are handled exclusively in the file writers:
 *       * WAV  : little-endian signed PCM samples
 *       * AIFF : big-endian signed PCM samples (AIFF-C not used here)
 *
 * Buffer/indexing:
 *   - This implementation preserves the program’s existing 1-based sample
 *     indexing convention: g_samples is incremented before writing a sample,
 *     and samples are stored at g_audio[g_samples].
 *
 * Safety:
 *   - Stops early if g_audio[] would overflow MAXSAMPLES.
 *
 * Globals used:
 *   - g_audio[], g_samples, g_scale, g_theta
 *   - g_twopioverrate, g_uspersample, g_fudge
 *
 * IMPORTANT:
 *   - Recommended: declare the buffer as `int16_t g_audio[MAXSAMPLES];`
 *     so the type matches the canonical signed PCM representation.
 *   - If you must keep `uint16_t`, store the bit-pattern of an `int16_t`
 *     sample (cast) and ensure writers interpret it as signed when emitting.
 * ============================================================================ */

static inline int16_t clamp_i16(int32_t v)
{
    if (v >  32767) return  32767;
    if (v < -32768) return -32768;
    return (int16_t)v;
}

void playtone(uint16_t tonefreq, double tonedur)
{
    uint32_t tonesamples;
    uint32_t i;
    double   deltatheta;

    /* apply prior fractional timing remainder */
    tonedur += g_fudge;

    /* duration (us) -> number of samples (rounded to nearest) */
    tonesamples = (uint32_t)((tonedur / g_uspersample) + 0.5);

    /* compute phase increment */
    deltatheta = g_twopioverrate * (double)tonefreq;

    for (i = 0; i < tonesamples; i++) {

        /* prevent buffer overflow */
        if (g_samples + 1 >= MAXSAMPLES) {
            /* preserve schedule remainder even if truncated */
            g_fudge = tonedur - ((double)tonesamples * g_uspersample);
            return;
        }

        g_samples++;

        if (tonefreq == 0) {
            /* silence in signed PCM is 0 */
            g_audio[g_samples] = 0;
        } else {
            /* signed PCM centered at 0 */
            int32_t v = (int32_t)lrint(sin(g_theta) * (double)g_scale);
            g_audio[g_samples] = clamp_i16(v);

            /* advance phase (phase-continuous across calls) */
            g_theta += deltatheta;

            /* keep theta bounded to avoid precision loss over long runs */
            if (g_theta > (2.0 * M_PI)) {
                g_theta = fmod(g_theta, 2.0 * M_PI);
            }
        }
    }

    /* carry forward fractional timing remainder */
    g_fudge = tonedur - ((double)tonesamples * g_uspersample);
}  /* end playtone */


/* ============================================================================
 * toneval_rgb()
 *
 * Purpose:
 *   - Map an 8-bit RGB color component value (0..255) to an SSTV audio tone
 *     frequency for RGB-based SSTV modes (e.g., Martin, Scottie).
 *
 * Mapping:
 *   - Output range: approximately 1500 Hz to 2300 Hz
 *   - Formula:
 *       freq = 1500 Hz + (800 Hz * colorval / 256)
 *
 * Inputs:
 *   - colorval : 8-bit RGB component (0..255)
 *
 * Returns:
 *   - Tone frequency in Hz (uint16_t)
 *
 * Notes:
 *   - Using division by 256 yields a maximum of ~2296 Hz at colorval=255.
 *     This is intentional and consistent with many SSTV encoders.
 *   - toneval_rgb() is used by Martin and Scottie family modes.
 * ============================================================================ */
uint16_t toneval_rgb(uint8_t colorval)
{
    return ((800 * colorval) / 256) + 1500;
}

/* ============================================================================
 * toneval_yuv()
 *
 * Purpose:
 *   - Map an 8-bit Y, R-Y (Cr), or B-Y (Cb) component value (0..255) to an SSTV
 *     audio tone frequency for YUV-based SSTV modes (e.g., Robot 36/72).
 *
 * Mapping:
 *   - Output range: approximately 1500 Hz to 2300 Hz
 *   - Formula:
 *       freq = 1500 Hz + (800 Hz * colorval / 255)
 *
 * Implementation:
 *   - Uses a floating-point scaling constant:
 *       800 / 255 ≈ 3.1372549
 *
 * Inputs:
 *   - colorval : 8-bit YUV component (0..255)
 *
 * Returns:
 *   - Tone frequency in Hz (uint16_t)
 *
 * Notes:
 *   - This mapping allows the maximum value (255) to reach ~2300 Hz.
 *   - toneval_yuv() is used by Robot family modes.
 * ============================================================================ */
uint16_t toneval_yuv(uint8_t colorval)
{
    return (uint16_t)((float)colorval * 3.1372549f + 1500.0f);
}
  
/* ============================================================================
 * addvisheader()
 *
 * Purpose:
 *   - Emit the standard SSTV "VIS" (Vertical Interval Signaling) header into
 *     the audio buffer so decoders can automatically identify the selected
 *     SSTV mode.
 *
 * Notes on naming:
 *   - Although historically described as “Martin 1 VIS header”, this function
 *     is mode-agnostic: it sends the VIS pattern for whatever 7-bit VIS code
 *     is currently stored in g_protocol.
 *
 * VIS header structure (as implemented):
 *   1) Silence:
 *        - 0 Hz (silence) for 500 ms
 *
 *   2) Attention tones (8 x 100 ms):
 *        1900, 1500, 1900, 1500, 2300, 1500, 2300, 1500 Hz
 *        (each tone 100 ms)
 *
 *   3) Leader / break / leader / start:
 *        - 1900 Hz for 300 ms   (leader)
 *        - 1200 Hz for 10 ms    (break)
 *        - 1900 Hz for 300 ms   (leader)
 *        - 1200 Hz for 30 ms    (VIS start)
 *
 *   4) VIS data bits (7 bits, LSB-first, each 30 ms):
 *        - Bit = 1  -> 1100 Hz for 30 ms
 *        - Bit = 0  -> 1300 Hz for 30 ms
 *        - Bits transmitted: i = 1,2,4,8,16,32,64 (LSB first)
 *
 *   5) Parity bit (30 ms):
 *        - Even parity across the 7 data bits
 *        - Implemented by toggling 'parity' on each '1' bit and transmitting:
 *            parity==1 (odd # of ones)  -> 1100 Hz (adds a 1 to make total even)
 *            parity==0 (even # of ones) -> 1300 Hz (adds a 0 to keep total even)
 *
 *   6) VIS stop bit:
 *        - 1200 Hz for 30 ms
 *
 * Globals used:
 *   - g_protocol : 7-bit VIS code for the selected SSTV mode
 *
 * Dependencies:
 *   - playtone(freq_hz, duration_us) where duration is in microseconds.
 * ============================================================================ */
void addvisheader(void)
{
    printf("[1/6] Adding VIS header...");

    /* (1) Silence */
    playtone(0, 500000);   /* 500 ms */

    /* (2) Attention tones (8 x 100 ms) */
    playtone(1900, 100000);
    playtone(1500, 100000);
    playtone(1900, 100000);
    playtone(1500, 100000);
    playtone(2300, 100000);
    playtone(1500, 100000);
    playtone(2300, 100000);
    playtone(1500, 100000);

    /* (3) Leader / break / leader / start */
    playtone(1900, 300000); /* leader */
    playtone(1200,  10000); /* break */
    playtone(1900, 300000); /* leader */
    playtone(1200,  30000); /* VIS start */

    /* (4) VIS data bits (7 bits, LSB-first) */
    int i;
    int parity = 0;

    for (i = 1; i <= 64; i <<= 1) {
        if (i & g_protocol) {      /* bit = 1 */
            playtone(1100, 30000);
            parity = !parity;
        } else {                   /* bit = 0 */
            playtone(1300, 30000);
        }
    }

    /* (5) Parity bit (even parity) */
    if (parity) {                  /* odd number of ones -> send 1 */
        playtone(1100, 30000);
    } else {                       /* even number of ones -> send 0 */
        playtone(1300, 30000);
    }

    /* (6) VIS stop */
    playtone(1200, 30000);

    printf(" Done.\n");
} /* end addvisheader */

/* ============================================================================
 * clamp_u8_round()
 *
 * Purpose:
 *   - Convert a floating-point component value into an 8-bit unsigned sample
 *     suitable for SSTV Y/Cr/Cb (or Y/R-Y/B-Y) component streams.
 *
 * Behavior:
 *   - Clamps input to the valid 8-bit range [0, 255].
 *   - Rounds to nearest integer using (v + 0.5) before casting.
 *
 * Inputs:
 *   - v: floating-point value (typically computed Y, R-Y, or B-Y).
 *
 * Returns:
 *   - uint8_t in [0, 255].
 *
 * Notes:
 *   - Use this after applying offsets/scaling (e.g., +16 for Y, +128 for chroma)
 *     to prevent underflow/overflow wrap when casting to uint8_t.
 * ============================================================================ */
static inline uint8_t clamp_u8_round(float v)
{
    if (v <= 0.0f)   return 0;
    if (v >= 255.0f) return 255;
    return (uint8_t)(v + 0.5f); /* round-to-nearest */
}

/* ============================================================================
 * playtone_samples() / playtone_dither_samples()
 *
 * Purpose:
 *   - Generate phase-continuous sine audio for an *exact integer number of
 *     samples* (playtone_samples), and provide a helper that supports
 *     *fractional* “samples-per-pixel” durations via error diffusion
 *     (playtone_dither_samples).
 *
 * Why this exists:
 *   - Robot SSTV pixel times (e.g., 431.25 µs and 215.625 µs) often correspond
 *     to non-integer sample counts at common sample rates (e.g., 22050 Hz).
 *     Example: 215.625 µs ≈ 4.75 samples @ 22.05 kHz.
 *   - If you round each pixel independently, timing error accumulates and/or
 *     introduces pixel-to-pixel jitter.
 *
 * Approach:
 *   - Dither in *sample space* (not microseconds):
 *       1) Keep an accumulator (*err_samp) holding the fractional remainder.
 *       2) Add it to ideal_samples for this pixel.
 *       3) Round to the nearest integer sample count for this emission.
 *       4) Carry the new fractional remainder forward.
 *   - Over many pixels, the average samples emitted converges to ideal_samples.
 *
 * Inputs:
 *   - freq_hz      : tone frequency in Hz (0 = silence).
 *   - tonesamples  : integer number of samples to emit (playtone_samples).
 *   - ideal_samples: desired (possibly fractional) samples to emit for one
 *                   pixel/tone segment (playtone_dither_samples).
 *   - err_samp     : pointer to a persistent fractional accumulator; initialize
 *                   to 0.0 at the start of each timing domain (e.g., per Y scan,
 *                   per Cr scan, per Cb scan).
 *
 * Output:
 *   - Appends signed 16-bit PCM samples to g_audio[] and advances g_theta
 *     phase-continuously across calls.
 *
 * Notes:
 *   - This bypasses any “duration->samples” rounding logic elsewhere and is
 *     intended for short pixel segments where consistent average timing matters.
 * ============================================================================ */

static inline void playtone_samples(uint16_t tonefreq, uint32_t tonesamples)
{
    const double deltatheta = g_twopioverrate * (double)tonefreq;

    for (uint32_t i = 0; i < tonesamples; i++) {
        if (g_samples + 1 >= MAXSAMPLES) return;

        g_samples++;

        if (tonefreq == 0) {
            g_audio[g_samples] = 0; /* silence */
        } else {
            int32_t v = (int32_t)lrint(sin(g_theta) * (double)g_scale);
            g_audio[g_samples] = clamp_i16(v);

            g_theta += deltatheta;
            if (g_theta > (2.0 * M_PI)) {
                g_theta = fmod(g_theta, 2.0 * M_PI);
            }
        }
    }
}

static inline void playtone_dither_samples(uint16_t freq_hz,
                                          double ideal_samples,
                                          double *err_samp)
{
    /* error diffusion in sample domain */
    const double d = ideal_samples + *err_samp;
    int32_t n = (int32_t)(d + 0.5);     /* round-to-nearest sample */
    *err_samp = d - (double)n;         /* carry remainder forward */

    if (n < 0) n = 0;
    playtone_samples(freq_hz, (uint32_t)n);
}

/* ============================================================================
 * Martin SSTV encoder (buildaudio_m)
 *
 * Applies to:
 *   - Martin 1 (M1) and Martin 2 (M2) color SSTV payload encoding
 *     (VIS/header is typically sent elsewhere; this function generates the
 *     per-line image scan audio only).
 *
 * Geometry:
 *   - 320 columns x 256 lines
 *
 * Per-line transmission structure (Martin family):
 *   1) Sync pulse:        1200 Hz for 4.862 ms  (4862 us)
 *   2) Porch / ref:       1500 Hz for 0.572 ms  ( 572 us)
 *   3) Green scan:        320 pixels @ pixeltime us/pixel
 *   4) Separator:         1500 Hz for 0.572 ms
 *   5) Blue scan:         320 pixels @ pixeltime us/pixel
 *   6) Separator:         1500 Hz for 0.572 ms
 *   7) Red scan:          320 pixels @ pixeltime us/pixel
 *   8) Separator:         1500 Hz for 0.572 ms
 *
 * Channel order:
 *   - G, then B, then R (per Martin specification)
 *
 * Pixel timing:
 *   - pixeltime is specified in microseconds and may be fractional.
 *     Common values:
 *       * Martin 1: 457.6 us/pixel
 *       * Martin 2: 228.8 us/pixel
 *
 * Implementation notes:
 *   - RGB source is a libgd truecolor image (gdImageGetTrueColorPixel).
 *   - toneval_rgb() maps a component value (0..255) to SSTV tone frequency.
 *   - playtone(freq_hz, duration_us) is assumed to accept integer microseconds.
 *     Fractional pixeltime is handled using playtone_dither() (error diffusion)
 *     to preserve correct *average* timing over a scan line.
 * ============================================================================ */
void buildaudio_m(double pixeltime)
{
    uint16_t x, y, k;
    uint32_t pixel;
    uint8_t r[320], g[320], b[320];

    printf("[3/6] Encoding Martin image to SSTV audio...");

    for (y = 0; y < 256; y++) {

        /* Read image row y (RGB) */
        for (x = 0; x < 320; x++) {
            pixel = gdImageGetTrueColorPixel(g_imgp, x, y);
            r[x] = (uint8_t)gdTrueColorGetRed(pixel);
            g[x] = (uint8_t)gdTrueColorGetGreen(pixel);
            b[x] = (uint8_t)gdTrueColorGetBlue(pixel);
        }

        /* Row sync + porch */
        playtone(1200, 4862);  /* 4.862 ms sync */
        playtone(1500,  572);  /* 0.572 ms porch */

        /* Use separate error accumulators per channel so dither error
           does not leak across channels or lines. */
        double err_g = 0.0, err_b = 0.0, err_r = 0.0;

        /* Green scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples((uint16_t)toneval_rgb(g[k]), pixeltime, &err_g);
        }

        /* Separator */
        playtone(1500, 572);

        /* Blue scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples((uint16_t)toneval_rgb(b[k]), pixeltime, &err_b);
        }

        /* Separator */
        playtone(1500, 572);

        /* Red scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples((uint16_t)toneval_rgb(r[k]), pixeltime, &err_r);
        }

        /* End-of-line separator / reference */
        playtone(1500, 572);
    }

    printf(" Done.\n");
}

/* ============================================================================
 * Scottie SSTV encoder (buildaudio_s)
 *
 * Applies to:
 *   - Scottie family RGB payload encoding (S1/S2/S3/S4/DX/DX2)
 *   - VIS/header is typically sent elsewhere; this function generates the image
 *     scan audio only.
 *
 * Modes (per provided specification table):
 *   - S1   : VIS 60, 256 lines x 320 cols, 140.115 LPM, ~110 s
 *   - S2   : VIS 56, 256 lines x 320 cols, 216.067 LPM, ~ 71 s
 *   - S3   : VIS 52, 128 lines x 320 cols, 140.115 LPM, ~ 55 s
 *   - S4   : VIS 48, 128 lines x 320 cols, 216.067 LPM, ~ 36 s
 *   - DX   : VIS 76, 256 lines x 320 cols,  57.127 LPM, ~269 s
 *   - DX2  : VIS 80, 256 lines x 320 cols, 112.905 LPM, ~136 s
 *
 * Geometry:
 *   - Columns: 320
 *   - Lines:   caller supplies line count (128 or 256 depending on mode)
 *
 * Per-line framing (as implemented):
 *   1) Separator/porch:  1500 Hz for 1.5 ms
 *   2) Green scan:       320 pixels @ pixeltime us/pixel
 *   3) Separator/porch:  1500 Hz for 1.5 ms
 *   4) Blue scan:        320 pixels @ pixeltime us/pixel
 *   5) Sync:             1200 Hz for 9.0 ms
 *   6) Porch:            1500 Hz for 1.5 ms
 *   7) Red scan:         320 pixels @ pixeltime us/pixel
 *
 * Timing model:
 *   - line_time = 960 * pixeltime + 13.5 ms
 *   - To match a target LPM:
 *       line_time = 60 / LPM
 *       pixeltime = (line_time - 0.0135) / 960
 *
 * Implementation notes:
 *   - RGB source is a libgd truecolor image (gdImageGetTrueColorPixel).
 *   - toneval_rgb() maps 0..255 RGB values to SSTV tone frequencies.
 *   - playtone(freq_hz, duration_us) is assumed to accept integer microseconds.
 *     Fractional pixeltime is emitted using playtone_dither() (error diffusion)
 *     to preserve correct *average* timing across the scan.
 * ============================================================================ */
void buildaudio_s(double pixeltime, uint16_t lines)
{
    uint16_t x, y, k;
    uint32_t pixel;
    uint8_t r[320], g[320], b[320];

    if (pixeltime <= 0.0 || (lines != 128 && lines != 256)) {
        return;
    }

    printf("[3/6] Encoding Scottie image to SSTV audio...");

    /* Optional start-of-image sync (kept from original; remove if undesired) */
    playtone(1200, 9000);

    for (y = 0; y < lines; y++) {

        /* Read image row y (RGB) */
        for (x = 0; x < 320; x++) {
            pixel = gdImageGetTrueColorPixel(g_imgp, x, y);
            r[x] = (uint8_t)gdTrueColorGetRed(pixel);
            g[x] = (uint8_t)gdTrueColorGetGreen(pixel);
            b[x] = (uint8_t)gdTrueColorGetBlue(pixel);
        }

        /* Separator/porch before Green */
        playtone(1500, 1500);

        /* Separate error accumulators per channel (per line) */
        double err_g = 0.0, err_b = 0.0, err_r = 0.0;

        /* Green scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples((uint16_t)toneval_rgb(g[k]), pixeltime, &err_g);
        }

        /* Separator/porch before Blue */
        playtone(1500, 1500);

        /* Blue scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples((uint16_t)toneval_rgb(b[k]), pixeltime, &err_b);
        }

        /* Sync + porch before Red */
        playtone(1200, 9000);
        playtone(1500, 1500);

        /* Red scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples((uint16_t)toneval_rgb(r[k]), pixeltime, &err_r);
        }
    }

    printf(" Done.\n");
}

/* ============================================================================
 * emit_scan_budgeted_u8()
 *
 * Helper for Robot 36 (and later): emit exactly budget_samp samples of pixel scans
 * using fractional-pixel dithering to prevent right-edge column artifacts.
 *
 * Parameters:
 *   - vals              : 320-element pixel array (SSTV tone values, 0..255).
 *   - budget_samp       : exact total samples to emit for the full scan.
 *   - ideal_samp_per_px : ideal samples/pixel (fractional allowed).
 *   - tone_map          : maps 0..255 -> SSTV tone frequency (Hz).
 *
 * Requires:
 *   - playtone_samples(freq_hz, samples) that writes exactly N samples and
 *     does NOT apply g_fudge or other duration rounding internally.
 * ============================================================================ */
static inline void emit_scan_budgeted_u8(const uint8_t *vals,
                                        uint32_t budget_samp,
                                        double ideal_samp_per_px,
                                        uint16_t (*tone_map)(uint8_t))
{
    double err = 0.0;
    uint32_t spent = 0;

    for (uint16_t i = 0; i < 319; i++) {
        double d = ideal_samp_per_px + err;
        int32_t n = (int32_t)(d + 0.5);     /* nearest integer samples */
        err = d - (double)n;
        if (n < 0) n = 0;

        spent += (uint32_t)n;
        playtone_samples(tone_map(vals[i]), (uint32_t)n);
    }

    /* Force exact scan length (prevents right-edge "extra column"). */
    {
        int32_t last = (int32_t)budget_samp - (int32_t)spent;
        if (last < 0) last = 0;
        playtone_samples(tone_map(vals[319]), (uint32_t)last);
    }
}

/* ============================================================================
 * Robot 36 SSTV encoder (buildaudio_r36) — spec-compliant Y, R-Y, B-Y (BT.601)
 *
 * Updated to match Appendix B (ChromaPIX / W95SSTV) "official" scalings:
 *   Y  = 16  + (1/256)*( 65.738*R + 129.057*G + 25.064*B )
 *   RY = 128 + (1/256)*(112.439*R -  94.154*G - 18.285*B )   // R-Y (Cr)
 *   BY = 128 + (1/256)*(-37.945*R -  74.494*G + 112.439*B )  // B-Y (Cb)
 *
 * Timing:
 *   Pixel scans remain sample-domain & budget-locked via emit_scan_budgeted_u8().
 *   Framing tones are emitted sample-exact using playtone_samples() to avoid
 *   g_fudge drift contaminating scan boundaries (prevents right-edge artifacts).
 * ============================================================================ */
 *
 * ============================================================================ */

/* ============================================================================
 * clampi_int()
 *
 * Purpose:
 *   Clamp an integer index into an inclusive range [lo, hi].
 *
 * Use:
 *   - Provides safe boundary handling for convolution/filters that require
 *     neighbor taps (x-2..x+2) near the edges of a scan line.
 *
 * Typical use:
 *   - x0 = clampi_int(x-2, 0, 319), etc.
 * ============================================================================ */
static inline int clampi_int(int v, int lo, int hi)
{
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
}

/* ============================================================================
 * emit_scan_budgeted_u8()
 *
 * Purpose:
 *   Emit exactly 320 SSTV "pixels" (tone segments) whose TOTAL length equals
 *   a specified scan budget in samples.
 *
 * Why:
 *   - Robot modes specify scan durations (e.g., 88 ms luma, 44 ms chroma).
 *   - At finite sample rates (especially 22.05 kHz), ideal pixel durations
 *     are fractional samples. If rounding error accumulates, some decoders
 *     smear the leftover time into a thin right-edge column artifact.
 *
 * Method:
 *   - Sample-domain error diffusion for the first 319 pixels:
 *       n_i = round(ideal_samp_per_px + err)
 *       err <- (ideal_samp_per_px + err) - n_i
 *   - Final (320th) pixel consumes the remaining sample budget so that:
 *       sum(n_i) == budget_samp exactly.
 *
 * Inputs:
 *   - vals[]            : 320 component values (0..255) for this scan segment.
 *   - budget_samp       : exact total samples to emit for the full scan.
 *   - ideal_samp_per_px : ideal samples/pixel (fractional allowed).
 *   - tone_map          : maps 0..255 -> SSTV tone frequency (Hz).
 *
 * Requires:
 *   - playtone_samples(freq_hz, samples) that writes exactly N samples and
 *     does NOT apply g_fudge or other duration rounding internally.
 * ============================================================================ */
static inline void emit_scan_budgeted_u8(const uint8_t *vals,
                                        uint32_t budget_samp,
                                        double ideal_samp_per_px,
                                        uint16_t (*tone_map)(uint8_t))
{
    double err = 0.0;
    uint32_t spent = 0;

    for (uint16_t i = 0; i < 319; i++) {
        double d = ideal_samp_per_px + err;
        int32_t n = (int32_t)(d + 0.5);     /* nearest integer samples */
        err = d - (double)n;
        if (n < 0) n = 0;

        spent += (uint32_t)n;
        playtone_samples(tone_map(vals[i]), (uint32_t)n);
    }

    /* Force exact scan length (prevents right-edge “extra column”). */
    {
        int32_t last = (int32_t)budget_samp - (int32_t)spent;
        if (last < 0) last = 0;
        playtone_samples(tone_map(vals[319]), (uint32_t)last);
    }
}

/* ============================================================================
 * Robot 36 SSTV encoder (buildaudio_r36) — spec-compliant Y, R-Y, B-Y (BT.601)
 *
 * Updated to match Appendix B (ChromaPIX / W95SSTV) "official" scalings:
 *   Y  = 16  + (1/256)*( 65.738*R + 129.057*G + 25.064*B )
 *   RY = 128 + (1/256)*(112.439*R -  94.154*G - 18.285*B )   // R-Y (Cr)
 *   BY = 128 + (1/256)*(-37.945*R -  74.494*G + 112.439*B )  // B-Y (Cb)
 *
 * Timing:
 *   Pixel scans remain sample-domain & budget-locked via emit_scan_budgeted_u8().
 *   Framing tones are emitted sample-exact using playtone_samples() to avoid
 *   g_fudge drift contaminating scan boundaries (prevents right-edge artifacts).
 * ============================================================================ */

void buildaudio_r36(void)
{
    uint32_t pixel1, pixel2;
    uint8_t  r1, g1, b1, r2, g2, b2;

    uint8_t y1[320], y2[320];
    uint8_t ry[320], by[320];          /* R-Y and B-Y bytes after filter */

    /* Work in float for chroma so filtering happens before quantization */
    float ryf[320], byf[320];
    float rytmp[320], bytmp[320];

    /* Appendix B exact 1/256 */
    const float K = 0.00390625f;

    /* Robot 36 pixel times in microseconds */
    const double Y_PIX_US = 275.0;   /* 88 ms / 320 */
    const double C_PIX_US = 137.5;   /* 44 ms / 320 */

    /* Convert to ideal samples-per-pixel (for emit_scan_budgeted_u8 dithering) */
    const double Y_PIX_S = Y_PIX_US / g_uspersample;
    const double C_PIX_S = C_PIX_US / g_uspersample;

    /* Exact scan budgets in samples — derived from pixel timing for consistency */
    const uint32_t Y_BUDGET_S = (uint32_t)llrint(320.0 * Y_PIX_S);
    const uint32_t C_BUDGET_S = (uint32_t)llrint(320.0 * C_PIX_S);

    /* Sample-exact framing (recommended for QA determinism) */
    const uint32_t SYNC_S      = (uint32_t)llrint(0.0090  * (double)g_rate);
    const uint32_t PORCH_S     = (uint32_t)llrint(0.0030  * (double)g_rate);
    const uint32_t SEP_S       = (uint32_t)llrint(0.0045  * (double)g_rate);
    const uint32_t SEP_PORCH_S = (uint32_t)llrint(0.0015  * (double)g_rate);

    /* Image bounds safety (don’t assume perfect 320x240 forever) */
    const int img_w = gdImageSX(g_imgp);
    const int img_h = gdImageSY(g_imgp);

    /* Hard requirement for Robot 36 source geometry */
    if (img_w < 320 || img_h < 240) {
        fprintf(stderr, "Error: Robot 36 requires at least 320x240 image (got %dx%d)\n",
                img_w, img_h);
        return;
    }

#ifdef DEBUG
    /* Validate tone mapper expectations (prevents accidental remap regressions) */
    {
        uint16_t f0 = toneval_yuv(0);
        uint16_t f255 = toneval_yuv(255);
        if (f0 > 1700 || f255 < 2100) {
            fprintf(stderr, "Warning: toneval_yuv range unexpected: %u..%u Hz\n", f0, f255);
        }
    }
#endif

    printf("[3/6] Encoding Robot 36 image to SSTV audio...");

    /* Process line pairs (2:1 vertical chroma) */
    for (int y = 0; y < 240; y += 2) {

        /* Clamp the second row index defensively */
        const int y_even = y;
        const int y_odd  = (y + 1 < 240) ? (y + 1) : y;

        /* Build Y for each row; build R-Y/B-Y from averaged RGB of the two rows */
        for (int x = 0; x < 320; x++) {

            pixel1 = gdImageGetTrueColorPixel(g_imgp, x, y_even);
            pixel2 = gdImageGetTrueColorPixel(g_imgp, x, y_odd);

            r1 = (uint8_t)gdTrueColorGetRed(pixel1);
            g1 = (uint8_t)gdTrueColorGetGreen(pixel1);
            b1 = (uint8_t)gdTrueColorGetBlue(pixel1);

            r2 = (uint8_t)gdTrueColorGetRed(pixel2);
            g2 = (uint8_t)gdTrueColorGetGreen(pixel2);
            b2 = (uint8_t)gdTrueColorGetBlue(pixel2);

            /* Spec luma Y (even / odd rows separately) */
            {
                float Ye = 16.0f + K * (65.738f*(float)r1 + 129.057f*(float)g1 + 25.064f*(float)b1);
                float Yo = 16.0f + K * (65.738f*(float)r2 + 129.057f*(float)g2 + 25.064f*(float)b2);
                y1[x] = clamp_u8_round(Ye);
                y2[x] = clamp_u8_round(Yo);
            }

            /* Average RGB for chroma (line-pair) */
            {
                float ar = 0.5f * ((float)r1 + (float)r2);
                float ag = 0.5f * ((float)g1 + (float)g2);
                float ab = 0.5f * ((float)b1 + (float)b2);

                /* Spec R-Y and B-Y (float, filter before quantize) */
                ryf[x] = 128.0f + K * (112.439f*ar + (-94.154f)*ag + (-18.285f)*ab);
                byf[x] = 128.0f + K * ((-37.945f)*ar + (-74.494f)*ag + 112.439f*ab);
            }
        }

        /* 5-tap binomial chroma LPF with clamped edges for ALL x:
         * [1 4 6 4 1] / 16
         *
         * Note: ryf/byf are fully populated for all x before filtering.
         */
        for (int x = 0; x < 320; x++) {
            int x0 = clampi_int(x - 2, 0, 319);
            int x1 = clampi_int(x - 1, 0, 319);
            int x2 = x;
            int x3 = clampi_int(x + 1, 0, 319);
            int x4 = clampi_int(x + 2, 0, 319);

            rytmp[x] = (ryf[x0] + 4.0f*ryf[x1] + 6.0f*ryf[x2] + 4.0f*ryf[x3] + ryf[x4]) * (1.0f/16.0f);
            bytmp[x] = (byf[x0] + 4.0f*byf[x1] + 6.0f*byf[x2] + 4.0f*byf[x3] + byf[x4]) * (1.0f/16.0f);
        }

        /* Quantize chroma after filtering */
        for (int x = 0; x < 320; x++) {
            ryf[x] = rytmp[x];
            byf[x] = bytmp[x];
            ry[x]  = clamp_u8_round(ryf[x]);
            by[x]  = clamp_u8_round(byf[x]);
        }

        /* ---- Robot 36 framing ---- */

        /* EVEN field (Y then R-Y) */
        playtone_samples(1200, SYNC_S);
        playtone_samples(1500, PORCH_S);

        emit_scan_budgeted_u8(y1, Y_BUDGET_S, Y_PIX_S, toneval_yuv);

        playtone_samples(1500, SEP_S);
        playtone_samples(1900, SEP_PORCH_S);

        emit_scan_budgeted_u8(ry, C_BUDGET_S, C_PIX_S, toneval_yuv);

        /* ODD field (Y then B-Y) */
        playtone_samples(1200, SYNC_S);
        playtone_samples(1500, PORCH_S);

        emit_scan_budgeted_u8(y2, Y_BUDGET_S, Y_PIX_S, toneval_yuv);

        playtone_samples(2300, SEP_S);
        playtone_samples(1900, SEP_PORCH_S);

        emit_scan_budgeted_u8(by, C_BUDGET_S, C_PIX_S, toneval_yuv);
    }

    printf(" Done.\n");
}

/* ============================================================================
 * Robot 72 SSTV encoder (buildaudio_r72)
 *
 * Summary:
 *   - Implements a full Robot 72 SSTV image encoder with correct line framing,
 *     timing, and YCbCr color handling suitable for software and FM paths.
 *
 * Key fixes and design choices:
 *   1) Pixel timing is dithered in the *sample domain* (not microseconds)
 *      to accurately represent fractional pixel durations
 *      (431.25 µs luma, 215.625 µs chroma) at 22050 Hz without accumulated
 *      drift or pixel-to-pixel jitter.
 *
 *   2) Scan-line framing strictly follows Robot 72 specification:
 *        - Sync and porch before luma
 *        - Identical separator/porch blocks between Y → Cr and Cr → Cb
 *      This avoids Robot-36-style separator patterns that can confuse
 *      Robot 72 decoders.
 *
 *   3) RGB → YCbCr conversion uses *full-range* BT.601 coefficients
 *      (0..255 luma, chroma centered at 128), matching the tone-mapping
 *      assumptions of Robot-family SSTV modes.
 *
 *   4) Chroma (Cr/Cb) is low-pass filtered horizontally in floating-point
 *      before quantization to 8-bit values. This reduces chroma bandwidth,
 *      minimizes quantization noise, and significantly improves color
 *      uniformity in Robot 72 decodes.
 *
 *   5) Final Y, Cr, and Cb values are clamped and rounded with
 *      clamp_u8_round() to prevent wraparound and ensure valid 8-bit inputs
 *      to toneval_yuv().
 *
 * Image format:
 *   - Resolution: 320 x 240 pixels
 *   - Source: libgd truecolor image (gdImageGetTrueColorPixel)
 *   - Color space: YCbCr (Robot-family encoding)
 *
 * Per-line scan structure (~300 ms total):
 *   1) Sync pulse:        1200 Hz for 9.0 ms
 *   2) Front porch:       1500 Hz for 3.0 ms
 *   3) Luma scan (Y):     320 pixels @ 431.25 µs/pixel ≈ 138.0 ms
 *   4) Separator block:   1500 Hz for 4.5 ms, then 1900 Hz for 1.5 ms (6.0 ms)
 *   5) Chroma scan (Cr):  320 pixels @ 215.625 µs/pixel ≈ 69.0 ms
 *   6) Separator block:   1500 Hz for 4.5 ms, then 1900 Hz for 1.5 ms (6.0 ms)
 *   7) Chroma scan (Cb):  320 pixels @ 215.625 µs/pixel ≈ 69.0 ms
 *
 * Notes:
 *   - toneval_yuv() maps 8-bit Y/Cr/Cb values (0..255) to approximately
 *     1500–2300 Hz, as expected by Robot-family SSTV decoders.
 *   - Short pixel segments use playtone_dither_samples() to ensure accurate
 *     average timing; fixed-duration blocks use playtone().
 * ============================================================================ */
void buildaudio_r72(void)
{
    uint16_t x, y, k;
    uint32_t pixel;
    uint8_t r, g, b;

    uint8_t ylum[320];
    uint8_t cr[320], cb[320];

    /* Work in float for chroma to avoid quantization noise before filtering */
    float crf[320], cbf[320];

    /* Robot 72 timings in microseconds */
    const double Y_PIX_US = 431.25;   /* 138 ms / 320 */
    const double C_PIX_US = 215.625;  /*  69 ms / 320 */

    /* Convert pixel durations to "ideal samples per pixel" */
    const double Y_PIX_S = Y_PIX_US / g_uspersample;
    const double C_PIX_S = C_PIX_US / g_uspersample;

    printf("[3/6] Encoding Robot 72 image to SSTV audio...");

    for (y = 0; y < 240; y++) {

        /* Build Y, Cr, Cb arrays for this row */
        for (x = 0; x < 320; x++) {
            pixel = gdImageGetTrueColorPixel(g_imgp, x, y);

            r = (uint8_t)gdTrueColorGetRed(pixel);
            g = (uint8_t)gdTrueColorGetGreen(pixel);
            b = (uint8_t)gdTrueColorGetBlue(pixel);

            /* Full-range BT.601 (0..255 luma, chroma centered at 128) */
            float Y  =  0.299000f  * r + 0.587000f  * g + 0.114000f  * b;
            float Cb = 128.0f + (-0.168736f * r) + (-0.331264f * g) + (0.500000f * b);
            float Cr = 128.0f + ( 0.500000f * r) + (-0.418688f * g) + (-0.081312f * b);

            ylum[x] = clamp_u8_round(Y);
            cbf[x]  = Cb;
            crf[x]  = Cr;
        }

        /* ---- Chroma low-pass filter (recommended) ----
         * 5-tap binomial: [1 4 6 4 1] / 16
         * This better matches Robot chroma bandwidth assumptions.
         */
        {
            float crtmp[320], cbtmp[320];

            /* Edge handling: replicate */
            crtmp[0]   = crf[0];
            crtmp[1]   = crf[1];
            crtmp[318] = crf[318];
            crtmp[319] = crf[319];

            cbtmp[0]   = cbf[0];
            cbtmp[1]   = cbf[1];
            cbtmp[318] = cbf[318];
            cbtmp[319] = cbf[319];

            for (x = 2; x < 318; x++) {
                crtmp[x] = (crf[x-2] + 4.0f*crf[x-1] + 6.0f*crf[x] + 4.0f*crf[x+1] + crf[x+2]) * (1.0f/16.0f);
                cbtmp[x] = (cbf[x-2] + 4.0f*cbf[x-1] + 6.0f*cbf[x] + 4.0f*cbf[x+1] + cbf[x+2]) * (1.0f/16.0f);
            }

            /* Copy back */
            for (x = 0; x < 320; x++) {
                crf[x] = crtmp[x];
                cbf[x] = cbtmp[x];
            }
        }

        /* Quantize chroma once, AFTER filtering */
        for (x = 0; x < 320; x++) {
            cr[x] = clamp_u8_round(crf[x]);
            cb[x] = clamp_u8_round(cbf[x]);
        }

        /* ---- Robot 72 scan-line framing ---- */

        /* Separate fractional accumulators per segment (in *samples*) */
        double err_y  = 0.0;
        double err_cr = 0.0;
        double err_cb = 0.0;

        /* (1) Sync + (2) porch */
        playtone(1200, 9000);   /* 9.0 ms */
        playtone(1500, 3000);   /* 3.0 ms */

        /* (3) Y scan (dither in samples) */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples(toneval_yuv(ylum[k]), Y_PIX_S, &err_y);
        }

        /* (4) Separator + porch */
        playtone(1500, 4500);   /* 4.5 ms */
        playtone(1900, 1500);   /* 1.5 ms */

        /* (5) Cr scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples(toneval_yuv(cr[k]), C_PIX_S, &err_cr);
        }

        /* (6) Separator + porch */
        playtone(1500, 4500);   /* 4.5 ms */
        playtone(1900, 1500);   /* 1.5 ms */

        /* (7) Cb scan */
        for (k = 0; k < 320; k++) {
            playtone_dither_samples(toneval_yuv(cb[k]), C_PIX_S, &err_cb);
        }
    }

    printf(" Done.\n");
}

/* ============================================================================
 * Robot B&W (luma-only) SSTV encoder (buildaudio_r36bw)
 *
 * Image:
 *   - 320 x 240 source RGB (libgd truecolor)
 *   - Transmits luma only (Y), mapped to SSTV tone range.
 *
 * Per-line framing (100 ms/line target):
 *   1) Sync:   1200 Hz for 9.0 ms
 *   2) Porch:  1500 Hz for 3.0 ms
 *   3) Y scan: 320 pixels @ 275 us/pixel = 88.0 ms
 *   Total: 9 + 3 + 88 = 100.0 ms (600 LPM)
 *
 * Luma:
 *   Y = 16 + (1/256)*( 65.738*R + 129.057*G + 25.064*B )
 *
 * Notes:
 *   - toneval_yuv() maps Y (0..255) to tone frequency (~1500..2300 Hz).
 * ============================================================================ */
void buildaudio_r36bw(void)
{
    uint16_t x, y, k;
    uint32_t pixel;
    uint8_t r, g, b;
    uint8_t ylum[320];

    const float K = 0.00390625f; /* exact 1/256 */

    printf("[3/6] Encoding Robot 36 B&W image to SSTV audio...");

    for (y = 0; y < 240; y++) {

        for (x = 0; x < 320; x++) {
            pixel = gdImageGetTrueColorPixel(g_imgp, x, y);

            r = (uint8_t)gdTrueColorGetRed(pixel);
            g = (uint8_t)gdTrueColorGetGreen(pixel);
            b = (uint8_t)gdTrueColorGetBlue(pixel);

            ylum[x] = clamp_u8_round(
                16.0f + K * ((65.738f * (float)r) +
                             (129.057f * (float)g) +
                             (25.064f * (float)b))
            );
        }

        /* Sync + porch */
        playtone(1200, 9000); /* 9.0 ms */
        playtone(1500, 3000); /* 3.0 ms */

        /* Y scan: 320 px @ 275 us = 88.0 ms */
        for (k = 0; k < 320; k++) {
            playtone(toneval_yuv(ylum[k]), 275.0);
        }

        /* No extra trailing separator: keeps line_time = 100.0 ms (600 LPM) */
    }

    printf(" Done.\n");
}

/* ============================================================================
 * Robot B&W (luma-only) SSTV encoder (320 x 240 @ 600 LPM)
 *
 * Image:
 *   - 320 x 240 source RGB (libgd truecolor)
 *   - Transmits luma only (Y)
 *
 * Per-line framing (100 ms/line, 600 LPM):
 *   1) Sync:   1200 Hz for 9.0 ms
 *   2) Porch:  1500 Hz for 3.0 ms
 *   3) Y scan: 320 pixels @ 275 us/pixel = 88.0 ms
 *   Total: 9 + 3 + 88 = 100.0 ms
 *
 * Luma:
 *   Y = 16 + (1/256)*(65.738*R + 129.057*G + 25.064*B)
 * ============================================================================ */
void buildaudio_r72bw(void)
{
    uint16_t x, y, k;
    uint32_t pixel;
    uint8_t r, g, b;
    uint8_t ylum[320];

    const float K = 0.00390625f; /* exact 1/256 */

    printf("[3/6] Encoding Robot 72 B&W image to SSTV audio...");

    for (y = 0; y < 240; y++) {

        for (x = 0; x < 320; x++) {
            pixel = gdImageGetTrueColorPixel(g_imgp, x, y);

            r = (uint8_t)gdTrueColorGetRed(pixel);
            g = (uint8_t)gdTrueColorGetGreen(pixel);
            b = (uint8_t)gdTrueColorGetBlue(pixel);

            ylum[x] = clamp_u8_round(
                16.0f + K * ((65.738f * (float)r) +
                             (129.057f * (float)g) +
                             (25.064f * (float)b))
            );
        }

        playtone(1200, 9000);
        playtone(1500, 3000);

        for (k = 0; k < 320; k++) {
            playtone(toneval_yuv(ylum[k]), 275.0);
        }
    }

    printf(" Done.\n");
}

/* ============================================================================
 * addvistrailer()
 *
 * Purpose:
 *   - Append an end-of-transmission tone sequence ("VIS trailer") to the audio
 *     stream after the image payload has been sent.
 *
 * What it does (as implemented):
 *   - Emits a short fixed pattern of tones followed by a 500 ms silence.
 *   - This is commonly used as an end marker / courtesy tail so receivers have
 *     time to finish decoding and record the final line(s) cleanly.
 *
 * Tone sequence:
 *   1) 2300 Hz for 300 ms
 *   2) 1200 Hz for 10 ms
 *   3) 2300 Hz for 100 ms
 *   4) 1200 Hz for 30 ms
 *   5) Silence for 500 ms (tonefreq = 0)
 *
 * Dependencies:
 *   - playtone(freq_hz, duration_us) where duration is in microseconds.
 *
 * Notes:
 *   - Unlike addvisheader(), this trailer does not encode g_protocol; it is a
 *     fixed end-of-transmission pattern.
 *   - If strict spec compliance for a particular SSTV family is required, you
 *     may want to confirm this trailer matches the expected post-image tones
 *     for that family (some encoders omit trailers or use different tails).
 * ============================================================================ */
void addvistrailer(void)
{
    printf("[5/6] Adding VIS trailer...");

    playtone(2300, 300000);  /* 300 ms */
    playtone(1200,  10000);  /* 10 ms  */
    playtone(2300, 100000);  /* 100 ms */
    playtone(1200,  30000);  /* 30 ms  */

    /* bit of silence */
    playtone(0, 500000);     /* 500 ms */

    printf(" Done.\n");
} /* end addvistrailer */


/* Write IEEE 754 80-bit extended float for a positive integer sample rate.
 * This is sufficient for common rates (8000..48000). */
static void write_aiff_ext80_rate(FILE *fp, uint32_t rate)
{
    if (rate == 0) rate = 1;

    int msb = 31 - __builtin_clz(rate);   // position of top set bit
    uint16_t exp = (uint16_t)(16383 + msb);

    uint64_t mant = (uint64_t)rate << (63 - msb);

    fputc((exp >> 8) & 0xFF, fp);
    fputc(exp & 0xFF, fp);

    for (int i = 7; i >= 0; i--) {
        fputc((mant >> (i * 8)) & 0xFF, fp);
    }
}

/* ============================================================================
 * writefile_aiff()
 *
 * Purpose:
 *   - Write the synthesized mono 16-bit audio samples in g_audio[] to an AIFF
 *     file stream (g_outfp).
 *
 * Output format (as written):
 *   - Container: AIFF ("FORM" ... "AIFF")
 *   - COMM chunk:
 *       * channels     = 1
 *       * numFrames    = g_samples
 *       * sampleSize   = 16 bits
 *       * sampleRate   = 11025 Hz (currently hard-coded in 80-bit extended form)
 *   - SSND chunk:
 *       * offset       = 0
 *       * blockSize    = 0
 *       * sound data   = big-endian 16-bit samples
 *
 * Data source:
 *   - g_audio[] contains sample values produced by playtone().
 *   - AUDIO_AIFF mode expects samples centered at 32768 (unsigned-ish) and
 *     writes them as big-endian 16-bit words.
 *
 * Important limitations / caveats:
 *   - The COMM sample rate bytes are hard-coded for 11025 Hz and do NOT track
 *     g_rate. If you allow -r to change sample rate, you must also update the
 *     AIFF sampleRate field accordingly or decoders/players will misinterpret
 *     playback speed.
 *   - Chunk size calculations assume:
 *       * 16-bit mono
 *       * SSND chunk with 8 bytes of offset+blocksize
 *       * g_samples samples
 *   - This function writes samples from i=0..g_samples (inclusive). If your
 *     code treats g_samples as the count of valid samples and writes starting
 *     at index 1, consider using i=1..g_samples for consistency.
 *
 * Globals used:
 *   - g_outfp, g_audio[], g_samples
 * ============================================================================ */
void writefile_aiff(void)
{
    uint32_t totalsize, audiosize, i;

    /* SSND data size = 8 bytes (offset+blockSize) + 2 bytes/sample * frames */
    audiosize = 8 + (2 * g_samples);

    /* FORM chunk size = (everything after the size field):
       4 ("AIFF") + (8+18) COMM + (8+audiosize) SSND */
    totalsize = 4 + 8 + 18 + 8 + audiosize;

    printf("[4/6] Writing AIFF audio data (%d samples, %.1f seconds at %d Hz)...", g_samples, (float)g_samples / g_rate, g_rate);

    /* "FORM" chunk */
    fputs("FORM", g_outfp);
    fputc((totalsize & 0xff000000) >> 24, g_outfp);
    fputc((totalsize & 0x00ff0000) >> 16, g_outfp);
    fputc((totalsize & 0x0000ff00) >>  8, g_outfp);
    fputc((totalsize & 0x000000ff)      , g_outfp);
    fputs("AIFF", g_outfp);

    /* "COMM" chunk */
    fputs("COMM", g_outfp);
    fputc(0, g_outfp);  /* chunk size = 18 */
    fputc(0, g_outfp);
    fputc(0, g_outfp);
    fputc(18, g_outfp);

    fputc(0, g_outfp);  /* channels = 1 */
    fputc(1, g_outfp);

    /* numFrames = g_samples */
    fputc((g_samples & 0xff000000) >> 24, g_outfp);
    fputc((g_samples & 0x00ff0000) >> 16, g_outfp);
    fputc((g_samples & 0x0000ff00) >>  8, g_outfp);
    fputc((g_samples & 0x000000ff)      , g_outfp);

    fputc(0, g_outfp);  /* sampleSize = 16 bits */
    fputc(16, g_outfp);

    /* sampleRate (80-bit extended float) */
    write_aiff_ext80_rate(g_outfp, g_rate);

    /* "SSND" chunk */
    fputs("SSND", g_outfp);
    fputc((audiosize & 0xff000000) >> 24, g_outfp);
    fputc((audiosize & 0x00ff0000) >> 16, g_outfp);
    fputc((audiosize & 0x0000ff00) >>  8, g_outfp);
    fputc((audiosize & 0x000000ff)      , g_outfp);

    /* offset (4) + blockSize (4) = 8 bytes, both zero */
    fputc(0, g_outfp); fputc(0, g_outfp); fputc(0, g_outfp); fputc(0, g_outfp);
    fputc(0, g_outfp); fputc(0, g_outfp); fputc(0, g_outfp); fputc(0, g_outfp);

    /* Audio samples (big-endian 16-bit words) */
    for (i = 1; i <= g_samples; i++) {
        int16_t s = g_audio[i];
        fputc((s >> 8) & 0xFF, g_outfp);
        fputc(s & 0xFF, g_outfp);
    }

    printf(" Done.\n");
}
/* ============================================================================


/* ============================================================================
 * writefile_wav()
 *
 * Purpose:
 *   - Write the synthesized audio samples in g_audio[] to a PCM WAV file.
 *
 * Output format:
 *   - RIFF/WAVE
 *   - PCM (format = 1)
 *   - Sample rate: g_rate
 *   - Channels: CHANS (currently 1)
 *   - Bits/sample: BITS (currently 16)
 *   - Data: little-endian signed PCM samples
 *
 * Important implementation detail:
 *   - The generator (playtone) increments g_samples once per emitted sample and
 *     stores into g_audio[g_samples]. This makes g_samples effectively the
 *     count of valid samples and uses 1-based indexing in g_audio[].
 *   - Therefore, we write samples for i = 1..g_samples (inclusive) and set the
 *     data chunk size to g_samples * CHANS * (BITS/8).
 *
 * Globals used:
 *   - g_outfp, g_audio[], g_samples, g_rate
 * ============================================================================ */
void writefile_wav(void)
{
    uint32_t audiosize, totalsize, byterate, blockalign;
    uint32_t i;

    audiosize  = (uint32_t)g_samples * (uint32_t)CHANS * (uint32_t)(BITS / 8);
    totalsize  = 4 + (8 + 16) + (8 + audiosize);                 /* RIFF size field */
    byterate   = (uint32_t)g_rate * (uint32_t)CHANS * (uint32_t)(BITS / 8);
    blockalign = (uint32_t)CHANS * (uint32_t)(BITS / 8);

    printf("[4/6] Writing WAV audio data (%d samples, %.1f seconds at %d Hz)...", g_samples, (float)g_samples / g_rate, g_rate);

    /* RIFF header */
    fputs("RIFF", g_outfp);

    /* RIFF chunk size (LE): file_size - 8 */
    fputc((totalsize & 0x000000ff)      , g_outfp);
    fputc((totalsize & 0x0000ff00) >>  8, g_outfp);
    fputc((totalsize & 0x00ff0000) >> 16, g_outfp);
    fputc((totalsize & 0xff000000) >> 24, g_outfp);

    fputs("WAVE", g_outfp);

    /* "fmt " subchunk */
    fputs("fmt ", g_outfp);

    /* fmt chunk size = 16 (LE) */
    fputc(16, g_outfp); fputc(0, g_outfp); fputc(0, g_outfp); fputc(0, g_outfp);

    /* Audio format = 1 (PCM) (LE 16-bit) */
    fputc(1, g_outfp);  fputc(0, g_outfp);

    /* Channels (LE 16-bit) */
    fputc((CHANS & 0x00ff)      , g_outfp);
    fputc((CHANS & 0xff00) >>  8, g_outfp);

    /* Sample rate (LE 32-bit) */
    fputc((g_rate & 0x000000ff)      , g_outfp);
    fputc((g_rate & 0x0000ff00) >>  8, g_outfp);
    fputc((g_rate & 0x00ff0000) >> 16, g_outfp);
    fputc((g_rate & 0xff000000) >> 24, g_outfp);

    /* Byte rate (LE 32-bit) */
    fputc((byterate & 0x000000ff)      , g_outfp);
    fputc((byterate & 0x0000ff00) >>  8, g_outfp);
    fputc((byterate & 0x00ff0000) >> 16, g_outfp);
    fputc((byterate & 0xff000000) >> 24, g_outfp);

    /* Block align (LE 16-bit) */
    fputc((blockalign & 0x00ff)      , g_outfp);
    fputc((blockalign & 0xff00) >>  8, g_outfp);

    /* Bits per sample (LE 16-bit) */
    fputc((BITS & 0x00ff)      , g_outfp);
    fputc((BITS & 0xff00) >>  8, g_outfp);

    /* "data" subchunk */
    fputs("data", g_outfp);

    /* data chunk size (LE 32-bit) */
    fputc((audiosize & 0x000000ff)      , g_outfp);
    fputc((audiosize & 0x0000ff00) >>  8, g_outfp);
    fputc((audiosize & 0x00ff0000) >> 16, g_outfp);
    fputc((audiosize & 0xff000000) >> 24, g_outfp);

    /* Audio samples (little-endian 16-bit) */
    for (i = 1; i <= g_samples; i++) {
        fputc((g_audio[i] & 0x00ff)     , g_outfp);
        fputc((g_audio[i] & 0xff00) >> 8, g_outfp);
    }

    printf(" Done.\n");
}
        
// end
