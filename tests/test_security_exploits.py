#!/usr/bin/env python3
"""
Security and Exploitation Testing for PiSSTVpp2
Tests robustness against malicious input including hex values, escape sequences,
command injection attempts, path traversal, buffer overflow, and other attacks
"""

import subprocess
import tempfile
import os
import sys
from pathlib import Path
from typing import Tuple, Optional
from dataclasses import dataclass

class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

@dataclass
class SecurityTestCase:
    """Represents a security-focused test case"""
    name: str
    args: list
    should_fail: bool = True
    description: str = ""
    
class SecurityExploitTestSuite:
    """Test suite for security vulnerabilities and exploitation techniques"""
    
    def __init__(self, executable_path="/Users/ssamjung/Desktop/WIP/PiSSTVpp2/bin/pisstvpp2"):
        self.exe = executable_path
        self.passed = 0
        self.failed = 0
        self.total = 0
        self.test_results = []
        self.vulnerabilities_found = []
        
        if not os.path.exists(self.exe):
            raise FileNotFoundError(f"Executable not found: {self.exe}")
        
        self.test_image = self._create_test_image()
    
    def _create_test_image(self) -> str:
        """Create a minimal PPM test image"""
        temp_dir = tempfile.gettempdir()
        test_image = os.path.join(temp_dir, "pisstvpp2_security_test.ppm")
        
        try:
            with open(test_image, 'wb') as f:
                f.write(b"P6\n320 256\n255\n")
                pixel = bytes([128, 128, 128])
                for _ in range(320 * 256):
                    f.write(pixel)
            return test_image
        except Exception as e:
            print(f"Warning: Could not create test image: {e}")
            return ""
    
    def _run_command(self, args: list) -> Tuple[int, str, str]:
        """Execute the command and capture output"""
        cmd = [self.exe] + args
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30,
                # Security: don't interpret shell metacharacters
                shell=False
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            return -1, "", "TIMEOUT"
        except Exception as e:
            return -1, "", str(e)
    
    def _log_result(self, test: SecurityTestCase, returncode: int, stdout: str, stderr: str):
        """Log test result"""
        passed = (returncode != 0) if test.should_fail else (returncode == 0)
        status = "PASS" if passed else "FAIL"
        color = Colors.GREEN if passed else Colors.RED
        
        print(f"{color}[{status}]{Colors.RESET} {test.name}")
        if test.description:
            print(f"     {Colors.CYAN}→ {test.description}{Colors.RESET}")
        
        if not passed:
            print(f"     Return code: {returncode}")
            if stderr:
                print(f"     Stderr: {stderr[:120]}")
        
        self.test_results.append({
            'name': test.name,
            'passed': passed,
            'returncode': returncode,
            'stderr': stderr,
            'stdout': stdout
        })
        
        if passed:
            self.passed += 1
        else:
            self.failed += 1
            if test.should_fail:
                self.vulnerabilities_found.append({
                    'type': 'REJECTION_FAILURE',
                    'test': test.name,
                    'details': f"Malicious input not rejected properly"
                })
        
        self.total += 1
    
    # ========================================================================
    # HEXADECIMAL AND OCTAL ENCODING ATTACKS
    # ========================================================================
    
    def test_hex_number_encoding(self):
        """Test hexadecimal encoded numeric parameters"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Hexadecimal Number Encoding ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Sample rate as hex (0x5622 = 22050)",
                ["-i", self.test_image, "-r", "0x5622"],
                should_fail=True,
                description="Should reject hex-encoded sample rate"
            ),
            SecurityTestCase(
                "Sample rate as hex (0x1f40 = 8000)",
                ["-i", self.test_image, "-r", "0x1f40"],
                should_fail=True,
                description="Should reject hex-encoded sample rate"
            ),
            SecurityTestCase(
                "CW WPM as hex (0x0F = 15)",
                ["-i", self.test_image, "-C", "N0CALL", "-W", "0x0F"],
                should_fail=True,
                description="Should reject hex-encoded WPM"
            ),
            SecurityTestCase(
                "CW Tone as hex (0x320 = 800)",
                ["-i", self.test_image, "-C", "N0CALL", "-T", "0x320"],
                should_fail=True,
                description="Should reject hex-encoded tone"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    def test_octal_number_encoding(self):
        """Test octal encoded numeric parameters"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Octal Number Encoding ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Sample rate as octal (052622 = 22050)",
                ["-i", self.test_image, "-r", "052622"],
                should_fail=True,
                description="Should reject octal-encoded sample rate"
            ),
            SecurityTestCase(
                "CW WPM as octal (017 = 15)",
                ["-i", self.test_image, "-C", "N0CALL", "-W", "017"],
                should_fail=True,
                description="Should reject octal-encoded WPM"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    def test_scientific_notation(self):
        """Test scientific notation in numeric parameters"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Scientific Notation ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Sample rate as scientific (2.205e4 = 22050)",
                ["-i", self.test_image, "-r", "2.205e4"],
                should_fail=True,
                description="Should reject scientific notation"
            ),
            SecurityTestCase(
                "Sample rate as scientific (8e3 = 8000)",
                ["-i", self.test_image, "-r", "8e3"],
                should_fail=True,
                description="Should reject scientific notation"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # ESCAPE SEQUENCE ATTACKS
    # ========================================================================
    
    def test_escape_sequences_in_parameters(self):
        """Test escape sequence handling in string parameters"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Escape Sequence Injection ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Filename with newline (\\n)",
                ["-i", self.test_image + "\n", "-o", "test"],
                should_fail=True,
                description="Should reject newline in filename"
            ),
            SecurityTestCase(
                "Filename with null byte (\\x00)",
                ["-i", self.test_image + "\x00extra", "-o", "test"],
                should_fail=True,
                description="Should reject null byte in filename"
            ),
            SecurityTestCase(
                "Protocol with escape sequence (m\\x311)",
                ["-i", self.test_image, "-p", "m\x311"],
                should_fail=True,
                description="Should reject escape sequences in protocol"
            ),
            SecurityTestCase(
                "Callsign with tab character",
                ["-i", self.test_image, "-C", "N0\tCALL"],
                should_fail=True,
                description="Should reject tab in callsign"
            ),
            SecurityTestCase(
                "Callsign with carriage return",
                ["-i", self.test_image, "-C", "N0CALL\r"],
                should_fail=True,
                description="Should reject carriage return in callsign"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # COMMAND INJECTION ATTEMPTS
    # ========================================================================
    
    def test_shell_command_injection(self):
        """Test shell command injection attempts"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Command Injection Attempts ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Filename with semicolon (;)",
                ["-i", self.test_image + "; echo hacked", "-o", "test"],
                should_fail=True,
                description="Should reject semicolon command separator"
            ),
            SecurityTestCase(
                "Filename with pipe (|)",
                ["-i", "test.ppm | cat /etc/passwd", "-o", "test"],
                should_fail=True,
                description="Should reject pipe operator"
            ),
            SecurityTestCase(
                "Filename with backticks",
                ["-i", "`whoami`.ppm", "-o", "test"],
                should_fail=True,
                description="Should reject backtick command substitution"
            ),
            SecurityTestCase(
                "Filename with $() substitution",
                ["-i", "$(whoami).ppm", "-o", "test"],
                should_fail=True,
                description="Should reject $() command substitution"
            ),
            SecurityTestCase(
                "Output filename with && operator",
                ["-i", self.test_image, "-o", "valid.wav && rm -rf /"],
                should_fail=True,
                description="Should reject && command chaining"
            ),
            SecurityTestCase(
                "Output filename with || operator",
                ["-i", self.test_image, "-o", "a.wav || cat /etc/passwd"],
                should_fail=True,
                description="Should reject || command chaining"
            ),
            SecurityTestCase(
                "Output filename with & background operator",
                ["-i", self.test_image, "-o", "a.wav &"],
                should_fail=True,
                description="Should reject & background operator"
            ),
            SecurityTestCase(
                "Callsign with backticks",
                ["-i", self.test_image, "-C", "`id`"],
                should_fail=True,
                description="Should reject backtick substitution in callsign"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # PATH TRAVERSAL AND FILE ACCESS ATTACKS
    # ========================================================================
    
    def test_path_traversal_attacks(self):
        """Test path traversal and directory escape attempts"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Path Traversal Attacks ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Input file with ../ traversal",
                ["-i", "../../../../../../etc/passwd", "-o", "test"],
                should_fail=True,
                description="Should reject path traversal in input file"
            ),
            SecurityTestCase(
                "Output file with ../ traversal",
                ["-i", self.test_image, "-o", "../../../tmp/evil.wav"],
                should_fail=True,
                description="Should handle path traversal safely"
            ),
            SecurityTestCase(
                "Input file with /etc/passwd",
                ["-i", "/etc/passwd", "-o", "test"],
                should_fail=True,
                description="Should reject absolute paths to system files"
            ),
            SecurityTestCase(
                "Input file pointing to /dev/zero",
                ["-i", "/dev/zero", "-o", "test"],
                should_fail=True,
                description="Should reject special device files"
            ),
            SecurityTestCase(
                "Output file to /tmp without validation",
                ["-i", self.test_image, "-o", "/tmp/pwned.wav"],
                should_fail=False,  # May be allowed, but should be monitored
                description="Output to /tmp should be handled safely"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # BUFFER OVERFLOW AND STRING LENGTH ATTACKS
    # ========================================================================
    
    def test_buffer_overflow_attempts(self):
        """Test very long strings that could cause buffer overflows"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Buffer Overflow Attempts ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Callsign: 256 characters",
                ["-i", self.test_image, "-C", "A" * 256],
                should_fail=True,
                description="Should reject callsign > max length"
            ),
            SecurityTestCase(
                "Protocol: 1024 characters",
                ["-i", self.test_image, "-p", "m" * 1024],
                should_fail=True,
                description="Should reject excessively long protocol"
            ),
            SecurityTestCase(
                "Format: 1024 characters",
                ["-i", self.test_image, "-f", "w" * 1024],
                should_fail=True,
                description="Should reject excessively long format"
            ),
            SecurityTestCase(
                "Filename: 2048 characters",
                ["-i", "a" * 2048, "-o", "test"],
                should_fail=True,
                description="Should reject excessively long filename"
            ),
            SecurityTestCase(
                "Sample rate: very long string",
                ["-i", self.test_image, "-r", "1" * 1000],
                should_fail=True,
                description="Should handle very long numeric input"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # FORMAT STRING ATTACKS
    # ========================================================================
    
    def test_format_string_attacks(self):
        """Test format string injection vulnerabilities"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Format String Attacks ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Callsign with format string (%x)",
                ["-i", self.test_image, "-C", "N0%x%x%x"],
                should_fail=True,
                description="Should not interpret format strings in arguments"
            ),
            SecurityTestCase(
                "Filename with %n format string",
                ["-i", "test%n.ppm", "-o", "test"],
                should_fail=True,
                description="Should not allow write format strings"
            ),
            SecurityTestCase(
                "Protocol with format string",
                ["-i", self.test_image, "-p", "m%p%p%p"],
                should_fail=True,
                description="Should not process format strings"
            ),
            SecurityTestCase(
                "Output file with format string",
                ["-i", self.test_image, "-o", "test_%x_%x.wav"],
                should_fail=True,
                description="Should not interpret format strings in filenames"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # QUOTE AND QUOTE ESCAPING ATTACKS
    # ========================================================================
    
    def test_quote_injection(self):
        """Test quote and quote escaping injection"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Quote Injection Attacks ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Filename with double quotes",
                ["-i", 'test"broken".ppm', "-o", "test"],
                should_fail=True,
                description="Should handle quotes in filename"
            ),
            SecurityTestCase(
                "Filename with single quotes",
                ["-i", "test'broken'.ppm", "-o", "test"],
                should_fail=True,
                description="Should handle single quotes in filename"
            ),
            SecurityTestCase(
                "Protocol with escaped quote",
                ["-i", self.test_image, "-p", 'm1\\"'],
                should_fail=True,
                description="Should reject escaped quotes"
            ),
            SecurityTestCase(
                "Callsign with both quote types",
                ["-i", self.test_image, "-C", '''N0"CALL' '''],
                should_fail=True,
                description="Should handle mixed quotes"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # SPECIAL CHARACTER AND ENCODING ATTACKS
    # ========================================================================
    
    def test_special_characters(self):
        """Test special character handling"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Special Character Handling ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Filename with spaces",
                ["-i", "test file.ppm", "-o", "test"],
                should_fail=False,  # Should handle spaces
                description="Should safely handle spaces in filenames"
            ),
            SecurityTestCase(
                "Callsign with spaces",
                ["-i", self.test_image, "-C", "N0 CALL"],
                should_fail=True,
                description="Should reject spaces in callsign"
            ),
            SecurityTestCase(
                "Protocol with special chars (!@#)",
                ["-i", self.test_image, "-p", "!@#$"],
                should_fail=True,
                description="Should reject special characters"
            ),
            SecurityTestCase(
                "Filename with unicode",
                ["-i", "tëst_ñ.ppm", "-o", "test"],
                should_fail=False,  # Depends on locale
                description="Should handle unicode safely"
            ),
            SecurityTestCase(
                "Callsign with unicode",
                ["-i", self.test_image, "-C", "Ñ0CALL"],
                should_fail=True,
                description="Should validate ASCII-only callsigns"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # ENVIRONMENTAL AND VARIABLE ATTACKS
    # ========================================================================
    
    def test_environment_variable_expansion(self):
        """Test environment variable injection"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Environment Variable Expansion ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Filename with $HOME expansion",
                ["-i", "$HOME/test.ppm", "-o", "test"],
                should_fail=True,
                description="Should not expand environment variables"
            ),
            SecurityTestCase(
                "Output with $HOME",
                ["-i", self.test_image, "-o", "$HOME/output.wav"],
                should_fail=True,
                description="Should not expand variables in output path"
            ),
            SecurityTestCase(
                "Filename with ${VAR} syntax",
                ["-i", "${HOME}/test.ppm", "-o", "test"],
                should_fail=True,
                description="Should not expand variable braces"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    # ========================================================================
    # SIGNAL AND CONTROL CHARACTER ATTACKS
    # ========================================================================
    
    def test_control_characters(self):
        """Test control character injection"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}=== Control Character Injection ==={Colors.RESET}")
        
        tests = [
            SecurityTestCase(
                "Filename with BEL character (\\x07)",
                ["-i", "test\x07.ppm", "-o", "test"],
                should_fail=True,
                description="Should reject control characters in filename"
            ),
            SecurityTestCase(
                "Callsign with ESC character (\\x1b)",
                ["-i", self.test_image, "-C", "N0\x1bCALL"],
                should_fail=True,
                description="Should reject escape character in callsign"
            ),
            SecurityTestCase(
                "Protocol with DEL character (\\x7f)",
                ["-i", self.test_image, "-p", "m1\x7f"],
                should_fail=True,
                description="Should reject DEL character"
            ),
        ]
        
        for test in tests:
            returncode, stdout, stderr = self._run_command(test.args)
            self._log_result(test, returncode, stdout, stderr)
    
    def run_all_tests(self):
        """Run all security and exploitation tests"""
        print(f"\n{Colors.BOLD}{Colors.CYAN}╔═══════════════════════════════════════════════════════════════╗{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.CYAN}║  Security & Exploitation Test Suite                            ║{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.CYAN}║  Tests robustness against malicious input and edge cases       ║{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.CYAN}╚═══════════════════════════════════════════════════════════════╝{Colors.RESET}")
        
        try:
            self.test_hex_number_encoding()
            self.test_octal_number_encoding()
            self.test_scientific_notation()
            self.test_escape_sequences_in_parameters()
            self.test_shell_command_injection()
            self.test_path_traversal_attacks()
            self.test_buffer_overflow_attempts()
            self.test_format_string_attacks()
            self.test_quote_injection()
            self.test_special_characters()
            self.test_environment_variable_expansion()
            self.test_control_characters()
        finally:
            if self.test_image and os.path.exists(self.test_image):
                os.remove(self.test_image)
        
        self._print_summary()
    
    def _print_summary(self):
        """Print comprehensive security test summary"""
        print(f"\n{Colors.BOLD}{Colors.BLUE}═══════════════════════════════════════════════════════════════{Colors.RESET}")
        print(f"{Colors.BOLD}Security Test Results:{Colors.RESET}")
        print(f"  {Colors.GREEN}Passed:  {self.passed}/{self.total}{Colors.RESET}")
        print(f"  {Colors.RED}Failed:  {self.failed}/{self.total}{Colors.RESET}")
        print(f"{Colors.BLUE}═══════════════════════════════════════════════════════════════{Colors.RESET}")
        
        if self.vulnerabilities_found:
            print(f"\n{Colors.BOLD}{Colors.RED}✗ VULNERABILITIES FOUND: {len(self.vulnerabilities_found)}{Colors.RESET}")
            print(f"{Colors.RED}{'─' * 63}{Colors.RESET}")
            for vuln in self.vulnerabilities_found:
                print(f"  Type: {vuln['type']}")
                print(f"  Test: {vuln['test']}")
                print(f"  Issue: {vuln['details']}")
                print()
        else:
            print(f"{Colors.GREEN}{Colors.BOLD}✓ No vulnerabilities detected!{Colors.RESET}")
        
        print(f"\n{Colors.BOLD}Test Coverage Areas:{Colors.RESET}")
        print(f"  • Hex/Octal/Scientific number encoding")
        print(f"  • Escape sequence injection")
        print(f"  • Command injection (;, |, backticks, $(), &&, ||, &)")
        print(f"  • Path traversal and directory escape")
        print(f"  • Buffer overflow attempts (long strings)")
        print(f"  • Format string attacks (%x, %n)")
        print(f"  • Quote and quote escaping")
        print(f"  • Special characters and unicode")
        print(f"  • Environment variable expansion")
        print(f"  • Control character injection")

if __name__ == "__main__":
    exe_path = "/Users/ssamjung/Desktop/WIP/PiSSTVpp2/bin/pisstvpp2" if len(sys.argv) == 1 else sys.argv[1]
    
    try:
        suite = SecurityExploitTestSuite(exe_path)
        suite.run_all_tests()
        sys.exit(0 if suite.vulnerabilities_found == [] else 1)
    except Exception as e:
        print(f"{Colors.RED}Error: {e}{Colors.RESET}")
        sys.exit(2)
